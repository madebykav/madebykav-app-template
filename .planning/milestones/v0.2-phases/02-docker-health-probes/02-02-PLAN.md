---
phase: 02-docker-health-probes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/health/route.ts
  - src/app/api/health/ready/route.ts
  - dev.sh
autonomous: true
requirements:
  - HLTH-01
  - HLTH-02
  - DOCK-04

must_haves:
  truths:
    - "GET /api/health returns 200 with {\"status\":\"ok\"}"
    - "GET /api/health/ready returns 200 with {\"status\":\"ready\"} when DB is reachable, or 503 with {\"status\":\"not ready\"} when DB is unreachable"
    - "./dev.sh starts postgres, waits for readiness, pushes schema, and launches the Next.js dev server"
  artifacts:
    - path: "src/app/api/health/route.ts"
      provides: "Liveness probe endpoint"
      exports: ["GET"]
    - path: "src/app/api/health/ready/route.ts"
      provides: "Readiness probe with DB connectivity check"
      exports: ["GET"]
    - path: "dev.sh"
      provides: "One-command dev environment setup script"
      contains: "docker compose --profile dev up"
  key_links:
    - from: "src/app/api/health/ready/route.ts"
      to: "src/lib/db/index.ts"
      via: "import { db } from '@/lib/db'"
      pattern: "import.*db.*from.*@/lib/db"
    - from: "src/app/api/health/ready/route.ts"
      to: "drizzle-orm"
      via: "import { sql } from 'drizzle-orm' for SELECT 1"
      pattern: "db\\.execute\\(sql"
    - from: "dev.sh"
      to: "docker-compose.yml"
      via: "docker compose --profile dev up -d"
      pattern: "docker compose.*profile dev"
    - from: "dev.sh"
      to: "pnpm db:push"
      via: "Schema push after postgres readiness"
      pattern: "pnpm db:push"
---

<objective>
Create health probe API routes (liveness and readiness) and the dev.sh one-command setup script.

Purpose: Health probes enable container orchestration (Kubernetes/Docker HEALTHCHECK) to monitor app state. dev.sh delivers the core value proposition: "clone to running app in one command."
Output: src/app/api/health/route.ts, src/app/api/health/ready/route.ts, dev.sh
</objective>

<execution_context>
@/Users/kavinda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kavinda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-docker-health-probes/02-RESEARCH.md
@src/lib/db/index.ts
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create liveness and readiness health probe routes</name>
  <files>src/app/api/health/route.ts, src/app/api/health/ready/route.ts</files>
  <action>
Create directory `src/app/api/health/` and `src/app/api/health/ready/`.

**Liveness probe** (`src/app/api/health/route.ts`):
```typescript
export async function GET() {
  return Response.json({ status: 'ok' })
}
```
This is intentionally minimal. Liveness probes must NOT check external dependencies (DB, etc.) -- if the DB goes down and liveness fails, the container restarts in a loop, which cannot fix the DB. Only return 200 to confirm the process is alive.

**Readiness probe** (`src/app/api/health/ready/route.ts`):
```typescript
import { db } from '@/lib/db'
import { sql } from 'drizzle-orm'

export async function GET() {
  try {
    await db.execute(sql`SELECT 1`)
    return Response.json({ status: 'ready' })
  } catch {
    return Response.json({ status: 'not ready' }, { status: 503 })
  }
}
```
The readiness probe checks DB connectivity with `SELECT 1` via drizzle-orm's `sql` template tag. Returns 200 when the DB is reachable (instance can serve traffic), 503 when unreachable (remove from load balancer but do NOT restart).

Import `db` from `@/lib/db` (the app's database instance). Import `sql` from `drizzle-orm` (already installed). No new dependencies needed.

Do NOT add authentication checks to health probes -- they must be accessible without auth for container orchestration.
  </action>
  <verify>
Verify files exist: `ls src/app/api/health/route.ts src/app/api/health/ready/route.ts`. Verify liveness returns JSON: grep for `Response.json` in health/route.ts. Verify readiness imports db: grep for `import.*db.*from` in health/ready/route.ts. Verify readiness catches errors: grep for `catch` in health/ready/route.ts. Verify no auth imports in either file.
  </verify>
  <done>GET /api/health returns {"status":"ok"} (liveness, no external deps checked). GET /api/health/ready returns {"status":"ready"} or 503 {"status":"not ready"} based on DB connectivity via SELECT 1.</done>
</task>

<task type="auto">
  <name>Task 2: Create dev.sh one-command setup script</name>
  <files>dev.sh</files>
  <action>
Create `dev.sh` at project root. Make it executable (`chmod +x dev.sh`).

```bash
#!/usr/bin/env bash
set -e

echo "=== MadeByKav App Dev Setup ==="

# Check for .env.local -- required for DATABASE_URL
if [ ! -f .env.local ]; then
  echo "No .env.local found. Copying from .env.example..."
  cp .env.example .env.local
  echo "Created .env.local -- review and update values if needed."
fi

# Start local postgres via docker compose
echo "Starting PostgreSQL..."
docker compose --profile dev up -d

echo "Waiting for PostgreSQL to be ready..."
until docker compose exec postgres pg_isready -U devuser -d app_dev > /dev/null 2>&1; do
  sleep 1
done
echo "PostgreSQL is ready."

# Push schema to local database (creates tables + RLS policies)
echo "Pushing database schema..."
pnpm db:push

echo "Starting Next.js dev server..."
exec pnpm dev
```

Key details:
- `set -e` exits on any error (fail fast)
- Checks for .env.local and copies from .env.example if missing. This enables true one-command setup from a fresh clone. The .env.example already has the correct local dev DATABASE_URL (`postgresql://devuser:devpassword@localhost:5433/app_dev`).
- `docker compose --profile dev up -d` starts only the postgres service (gated by dev profile)
- `pg_isready` loop waits for postgres to accept connections before pushing schema
- `pnpm db:push` applies the drizzle schema (tables + declarative RLS policies from Phase 1)
- `exec pnpm dev` replaces the shell process with the Next.js dev server (clean signal handling, Ctrl+C works)
- Do NOT add cleanup traps for docker compose down -- the developer controls when to stop postgres separately

After creating the file, run `chmod +x dev.sh` to make it executable.
  </action>
  <verify>
Verify file exists and is executable: `ls -la dev.sh` should show `x` permission bits. Verify shebang: `head -1 dev.sh` should be `#!/usr/bin/env bash`. Verify .env.local check: grep for `.env.local` in dev.sh. Verify docker compose command: grep for `docker compose --profile dev` in dev.sh. Verify pg_isready wait loop: grep for `pg_isready` in dev.sh. Verify schema push: grep for `pnpm db:push` in dev.sh. Verify dev server: grep for `pnpm dev` in dev.sh.
  </verify>
  <done>dev.sh is executable, checks for .env.local (copies from .env.example if missing), starts postgres via docker compose dev profile, waits for readiness with pg_isready, pushes schema with pnpm db:push, and launches Next.js dev server with exec pnpm dev.</done>
</task>

</tasks>

<verification>
1. `ls src/app/api/health/route.ts src/app/api/health/ready/route.ts dev.sh` -- all three files exist
2. `grep 'status.*ok' src/app/api/health/route.ts` -- liveness returns ok
3. `grep 'SELECT 1' src/app/api/health/ready/route.ts` -- readiness checks DB
4. `grep '503' src/app/api/health/ready/route.ts` -- readiness returns 503 on failure
5. `test -x dev.sh && echo "executable"` -- dev.sh is executable
6. `grep 'docker compose --profile dev' dev.sh` -- correct compose command
7. `grep 'pg_isready' dev.sh` -- postgres readiness wait present
8. `grep '.env.local' dev.sh` -- env file check present
</verification>

<success_criteria>
- GET /api/health returns {"status":"ok"} without checking external dependencies
- GET /api/health/ready checks DB with SELECT 1, returns {"status":"ready"} or 503 {"status":"not ready"}
- dev.sh is executable, auto-creates .env.local from .env.example if missing, starts postgres, waits for readiness, pushes schema, and starts dev server
- No new npm dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/02-docker-health-probes/02-02-SUMMARY.md`
</output>
