---
phase: 02-docker-health-probes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - docker-compose.yml
  - public/.gitkeep
autonomous: true
requirements:
  - DOCK-01
  - DOCK-02
  - DOCK-03

must_haves:
  truths:
    - "docker build produces a working standalone image with non-root user"
    - "docker-compose --profile dev up -d starts a postgres container on port 5433"
    - ".dockerignore excludes node_modules, .next, .git, .env*, *.md, drizzle/, .planning/"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build (base/deps/builder/runner) with standalone output"
      contains: "FROM node:22-alpine"
    - path: ".dockerignore"
      provides: "Build context exclusions"
      contains: "node_modules"
    - path: "docker-compose.yml"
      provides: "Dev postgres service with profile gating"
      contains: "postgres:16-alpine"
    - path: "public/.gitkeep"
      provides: "Empty public directory for Dockerfile COPY"
  key_links:
    - from: "Dockerfile"
      to: ".npmrc"
      via: "COPY .npmrc for registry config + BuildKit secret for auth token"
      pattern: "mount=type=secret,id=GITHUB_TOKEN"
    - from: "Dockerfile"
      to: "public/.gitkeep"
      via: "COPY --from=builder /app/public ./public"
      pattern: "COPY.*public"
    - from: "Dockerfile"
      to: "/api/health"
      via: "HEALTHCHECK CMD wget"
      pattern: "HEALTHCHECK.*localhost:3000/api/health"
---

<objective>
Create Docker infrastructure files: multi-stage Dockerfile with BuildKit secrets for private package auth, .dockerignore for clean build context, and docker-compose.yml with dev-profile postgres on port 5433.

Purpose: Enable `docker build` to produce a production-ready standalone image and provide a local dev postgres via docker-compose for the dev.sh script (created in Plan 02).
Output: Dockerfile, .dockerignore, docker-compose.yml, public/.gitkeep
</objective>

<execution_context>
@/Users/kavinda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kavinda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-docker-health-probes/02-RESEARCH.md
@.npmrc
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile with multi-stage build and BuildKit secrets</name>
  <files>Dockerfile, public/.gitkeep</files>
  <action>
Create `public/.gitkeep` (empty file) so the Dockerfile COPY for public/ does not fail.

Create `Dockerfile` with four stages:

**Stage 1 - base:** `FROM node:22-alpine AS base`. Run `corepack enable` to activate pnpm.

**Stage 2 - deps:** `FROM base AS deps`. WORKDIR /app. COPY package.json, pnpm-lock.yaml, and .npmrc. Use BuildKit secret mount to inject GITHUB_TOKEN for private @madebykav package auth:
```dockerfile
RUN --mount=type=secret,id=GITHUB_TOKEN \
    echo "//npm.pkg.github.com/:_authToken=$(cat /run/secrets/GITHUB_TOKEN)" >> .npmrc && \
    pnpm install --frozen-lockfile && \
    sed -i '/authToken/d' .npmrc
```
This appends the auth token to .npmrc for install, then strips it after. The secret never persists in image layers. This addresses the STATE.md blocker about NPM_TOKEN leaking.

**Stage 3 - builder:** `FROM base AS builder`. WORKDIR /app. COPY node_modules from deps stage. COPY all source files. Run `pnpm build`. Next.js `output: 'standalone'` is already configured in next.config.ts.

**Stage 4 - runner:** `FROM base AS runner`. WORKDIR /app. Set `ENV NODE_ENV=production`. Create non-root user:
```dockerfile
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs
```
COPY standalone output, static assets, and public directory with correct ownership:
```dockerfile
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
COPY --from=builder --chown=nextjs:nodejs /app/public ./public
```
Switch to non-root user with `USER nextjs`. EXPOSE 3000. Set `ENV PORT=3000 HOSTNAME="0.0.0.0"`. Add HEALTHCHECK using wget (available in Alpine BusyBox):
```dockerfile
HEALTHCHECK CMD wget -qO- http://localhost:3000/api/health || exit 1
```
CMD is `["node", "server.js"]`.

Do NOT use `--build-arg` for tokens. Do NOT include a `version:` field in any Docker file. Do NOT use `corepack prepare` -- just `corepack enable` suffices on Node 22.
  </action>
  <verify>
Verify Dockerfile syntax: `head -5 Dockerfile` should show `FROM node:22-alpine AS base`. Verify public/.gitkeep exists: `ls public/.gitkeep`. Verify BuildKit secret mount pattern: grep for `mount=type=secret` in Dockerfile. Verify no ARG for tokens: grep should find no `ARG.*TOKEN` in Dockerfile.
  </verify>
  <done>Dockerfile has 4 stages (base/deps/builder/runner), uses BuildKit secret mount for GITHUB_TOKEN, runs as non-root nextjs user, and includes HEALTHCHECK. public/.gitkeep exists.</done>
</task>

<task type="auto">
  <name>Task 2: Create .dockerignore and docker-compose.yml</name>
  <files>.dockerignore, docker-compose.yml</files>
  <action>
Create `.dockerignore` with the following entries (one per line):
```
node_modules
.next
.git
.gitignore
.env*
*.md
drizzle/
.planning/
.vscode/
```
This keeps the Docker build context minimal by excluding dependencies (copied separately), build output, git history, secrets, documentation, migration artifacts, and planning files. The `.env*` pattern excludes .env.local, .env.example, etc.

Create `docker-compose.yml` (no `version:` field -- obsolete in Compose v2):
```yaml
services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: devuser
      POSTGRES_PASSWORD: devpassword
      POSTGRES_DB: app_dev
    ports:
      - "5433:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    profiles:
      - dev

volumes:
  pgdata:
```
Key details:
- Port 5433 on host maps to 5432 in container (avoids system postgres conflict)
- `profiles: [dev]` gates the service -- only starts with `docker compose --profile dev up`
- Named volume `pgdata` persists data across restarts (cleared with `docker compose down -v`)
- Credentials match .env.example DATABASE_URL: `postgresql://devuser:devpassword@localhost:5433/app_dev`
  </action>
  <verify>
Verify .dockerignore contains expected entries: grep for `node_modules`, `.next`, `.env*`, `.planning/` in .dockerignore. Verify docker-compose.yml is valid YAML: `docker compose config -q` (should produce no errors if Docker is installed, otherwise just check file exists). Verify no `version:` field in docker-compose.yml.
  </verify>
  <done>.dockerignore excludes node_modules, .next, .git, .env*, *.md, drizzle/, and .planning/. docker-compose.yml defines a postgres:16-alpine service on port 5433 with dev profile, named volume, and credentials matching .env.example.</done>
</task>

</tasks>

<verification>
1. `ls Dockerfile .dockerignore docker-compose.yml public/.gitkeep` -- all four files exist
2. `grep -c 'FROM.*AS' Dockerfile` -- returns 4 (four stages)
3. `grep 'mount=type=secret' Dockerfile` -- BuildKit secret mount present
4. `grep 'USER nextjs' Dockerfile` -- non-root user configured
5. `grep 'HEALTHCHECK' Dockerfile` -- health check directive present
6. `grep 'profiles' docker-compose.yml` -- dev profile gating present
7. `grep '5433:5432' docker-compose.yml` -- correct port mapping
8. `grep 'node_modules' .dockerignore` -- key exclusion present
</verification>

<success_criteria>
- Dockerfile builds a 4-stage image (base/deps/builder/runner) using node:22-alpine, BuildKit secrets for private package auth, non-root nextjs user, and HEALTHCHECK
- .dockerignore excludes node_modules, .next, .git, .env*, *.md, drizzle/, .planning/
- docker-compose.yml provides postgres:16-alpine on port 5433 with dev profile and persistent volume
- public/.gitkeep exists so Dockerfile COPY does not fail
</success_criteria>

<output>
After completion, create `.planning/phases/02-docker-health-probes/02-01-SUMMARY.md`
</output>
